/** * University of Illinois/NCSA * Open Source License *  * Copyright (c) 2008, Board of Trustees-University of Illinois.   * All rights reserved. *  * Developed by:  *  * Automated Learning Group * National Center for Supercomputing Applications * http://www.seasr.org *  *   * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to * deal with the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:  *  *  * Redistributions of source code must retain the above copyright notice, *    this list of conditions and the following disclaimers.  *  *  * Redistributions in binary form must reproduce the above copyright notice, *    this list of conditions and the following disclaimers in the  *    documentation and/or other materials provided with the distribution.  *  *  * Neither the names of Automated Learning Group, The National Center for *    Supercomputing Applications, or University of Illinois, nor the names of *    its contributors may be used to endorse or promote products derived from *    this Software without specific prior written permission.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE * CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * WITH THE SOFTWARE. */ /* Generated By:JavaCC: Do not edit this line. BrownStandardParser.java */package org.seasr.components.text.tokenize.brown;/** *  * Parser for tokenizing a corpus into Brown Corpus Standard Format. *  */import org.seasr.components.text.datatype.pos.PoSToken;import org.seasr.components.text.datatype.pos.TokenFlag;import java.util.ArrayList;import java.util.Vector;import java.util.logging.*;public class BrownStandardParser implements BrownStandardParserConstants {	private static Logger _logger = Logger.getLogger("BrownStandardParser");	public static void main(String[] args) {		BrownStandardParser parser;		String filename = null;		long initTime = 0;		long parseTime = 0;		long startTime = 0;		long stopTime = 0;		if (args.length == 0) {			_logger					.info("BrownStandardParser Version 1.0:  Reading from standard input . . .");			parser = new BrownStandardParser(System.in);		} else if (args.length == 1) {			filename = args[0];			_logger.info("BrownStandardParser Version 1.0 Reading from file "					+ filename + " . . .");			try {				startTime = System.currentTimeMillis();				parser = new BrownStandardParser(new java.io.FileInputStream(						filename));				stopTime = System.currentTimeMillis();				initTime = stopTime - startTime;			} catch (java.io.FileNotFoundException e) {				_logger.severe("BrownStandardParser Version 1.0:  File "						+ filename + " not found.");				return;			}		} else {			_logger.info("BrownStandardParser Version 1.0:  Usage is one of:");			_logger.info("         java BrownStandardParser < inputfile");			_logger.info("OR");			_logger.info("         java BrownStandardParser inputfile");			return;		}		try {			startTime = System.currentTimeMillis();			parser.corpus();			stopTime = System.currentTimeMillis();			parseTime = stopTime - startTime;			_logger.info("BrownStandardParser Version 1.0: ");			_logger.info("   Java program parsed " + filename					+ " successfully in " + (initTime + parseTime) + " ms.");			_logger.info("      parser initialization time was " + initTime					+ " ms.");			_logger.info("      parser parse time was " + parseTime + " ms.");		} catch (Exception e) {			_logger.severe(e.getMessage());			_logger					.severe("BrownStandardParser Version 1.0:  Encountered errors during parse.");		}	}	/** **************************************** */	/** ************* Rules ******************** */	/** **************************************** */	final public ArrayList<PoSToken> corpus() throws ParseException {		ArrayList<PoSToken> doc = new ArrayList<PoSToken>();		boolean newLine = true;		label_1: while (true) {			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {			case SPECIAL:			case WS:			case ACRO:			case EOS:			case SYM:			case DASH:			case POS1:			case POS2:			case DIGIT:			case GARBAGE:				;				break;			default:				jj_la1[0] = jj_gen;				break label_1;			}			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {			case WS:				jj_consume_token(WS);				break;			case GARBAGE:				jj_consume_token(GARBAGE);				break;			case EOS:				jj_consume_token(EOS);				doc.add(new PoSToken(token.image.trim(), TokenFlag.END_OF_LINE));				newLine = true;				break;			case SYM:				jj_consume_token(SYM);				if (newLine) {					doc.add(new PoSToken(token.image.trim(),							TokenFlag.START_OF_LINE));					newLine = false;				} else {					doc.add(new PoSToken(token.image));				}				break;			case DASH:				jj_consume_token(DASH);				if (newLine) {					doc.add(new PoSToken(token.image.trim(),							TokenFlag.START_OF_LINE));					newLine = false;				} else {					doc.add(new PoSToken("--"));				}				break;			case POS1:				jj_consume_token(POS1);				if (newLine) {					doc.add(new PoSToken(token.image.trim(),							TokenFlag.START_OF_LINE));					newLine = false;				} else {					doc.add(new PoSToken(token.image));				}				break;			case POS2:				jj_consume_token(POS2);				if (newLine) {					doc.add(new PoSToken(token.image.trim(),							TokenFlag.START_OF_LINE));					newLine = false;				} else {					doc.add(new PoSToken(token.image));				}				break;			case ACRO:				jj_consume_token(ACRO);				if (newLine) {					doc.add(new PoSToken(token.image.trim(),							TokenFlag.START_OF_LINE));					newLine = false;				} else {					doc.add(new PoSToken(token.image));				}				break;			case SPECIAL:				jj_consume_token(SPECIAL);				if (newLine) {					doc.add(new PoSToken(token.image.trim(),							TokenFlag.START_OF_LINE));					newLine = false;				} else {					doc.add(new PoSToken(token.image));				}				break;			case DIGIT:				jj_consume_token(DIGIT);				if (newLine) {					doc.add(new PoSToken(token.image.trim(),							TokenFlag.START_OF_LINE));					newLine = false;				} else {					doc.add(new PoSToken(token.image));				}				break;			default:				jj_la1[1] = jj_gen;				jj_consume_token(-1);				throw new ParseException();			}		}		jj_consume_token(0);		PoSToken pt = (PoSToken) doc.get(doc.size() - 1);		if (!pt.isFlagged(TokenFlag.END_OF_LINE)) {			pt.addFlag(TokenFlag.END_OF_LINE);		}		{			if (true)				return doc;		}		throw new Error("Missing return statement in function");	}	public BrownStandardParserTokenManager token_source;	ASCII_CharStream jj_input_stream;	public Token token, jj_nt;	private int jj_ntk;	private int jj_gen;	final private int[] jj_la1 = new int[2];	final private int[] jj_la1_0 = { 0x7fe, 0x7fe, };	public BrownStandardParser(java.io.InputStream stream) {		jj_input_stream = new ASCII_CharStream(stream, 1, 1);		token_source = new BrownStandardParserTokenManager(jj_input_stream);		token = new Token();		jj_ntk = -1;		jj_gen = 0;		for (int i = 0; i < 2; i++)			jj_la1[i] = -1;	}	public void ReInit(java.io.InputStream stream) {		jj_input_stream.ReInit(stream, 1, 1);		token_source.ReInit(jj_input_stream);		token = new Token();		jj_ntk = -1;		jj_gen = 0;		for (int i = 0; i < 2; i++)			jj_la1[i] = -1;	}	public BrownStandardParser(java.io.Reader stream) {		jj_input_stream = new ASCII_CharStream(stream, 1, 1);		token_source = new BrownStandardParserTokenManager(jj_input_stream);		token = new Token();		jj_ntk = -1;		jj_gen = 0;		for (int i = 0; i < 2; i++)			jj_la1[i] = -1;	}	public void ReInit(java.io.Reader stream) {		jj_input_stream.ReInit(stream, 1, 1);		token_source.ReInit(jj_input_stream);		token = new Token();		jj_ntk = -1;		jj_gen = 0;		for (int i = 0; i < 2; i++)			jj_la1[i] = -1;	}	public BrownStandardParser(BrownStandardParserTokenManager tm) {		token_source = tm;		token = new Token();		jj_ntk = -1;		jj_gen = 0;		for (int i = 0; i < 2; i++)			jj_la1[i] = -1;	}	public void ReInit(BrownStandardParserTokenManager tm) {		token_source = tm;		token = new Token();		jj_ntk = -1;		jj_gen = 0;		for (int i = 0; i < 2; i++)			jj_la1[i] = -1;	}	final private Token jj_consume_token(int kind) throws ParseException {		Token oldToken;		if ((oldToken = token).next != null)			token = token.next;		else			token = token.next = token_source.getNextToken();		jj_ntk = -1;		if (token.kind == kind) {			jj_gen++;			return token;		}		token = oldToken;		jj_kind = kind;		throw generateParseException();	}	final public Token getNextToken() {		if (token.next != null)			token = token.next;		else			token = token.next = token_source.getNextToken();		jj_ntk = -1;		jj_gen++;		return token;	}	final public Token getToken(int index) {		Token t = token;		for (int i = 0; i < index; i++) {			if (t.next != null)				t = t.next;			else				t = t.next = token_source.getNextToken();		}		return t;	}	final private int jj_ntk() {		if ((jj_nt = token.next) == null)			return (jj_ntk = (token.next = token_source.getNextToken()).kind);		else			return (jj_ntk = jj_nt.kind);	}	private Vector<int[]> jj_expentries = new Vector<int[]>();	private int[] jj_expentry;	private int jj_kind = -1;	final public ParseException generateParseException() {		jj_expentries.removeAllElements();		boolean[] la1tokens = new boolean[11];		for (int i = 0; i < 11; i++) {			la1tokens[i] = false;		}		if (jj_kind >= 0) {			la1tokens[jj_kind] = true;			jj_kind = -1;		}		for (int i = 0; i < 2; i++) {			if (jj_la1[i] == jj_gen) {				for (int j = 0; j < 32; j++) {					if ((jj_la1_0[i] & (1 << j)) != 0) {						la1tokens[j] = true;					}				}			}		}		for (int i = 0; i < 11; i++) {			if (la1tokens[i]) {				jj_expentry = new int[1];				jj_expentry[0] = i;				jj_expentries.addElement(jj_expentry);			}		}		int[][] exptokseq = new int[jj_expentries.size()][];		for (int i = 0; i < jj_expentries.size(); i++) {			exptokseq[i] = (int[]) jj_expentries.elementAt(i);		}		return new ParseException(token, exptokseq, tokenImage);	}	final public void enable_tracing() {	}	final public void disable_tracing() {	}}